"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_chain_1 = require("stream-chain");
const providers_1 = require("../../providers");
const createPushController = (options) => {
    const provider = (0, providers_1.createLocalStrapiDestinationProvider)(options);
    const streams = {};
    const assets = {};
    const writeAsync = (stream, data) => {
        return new Promise((resolve, reject) => {
            stream.write(data, (error) => {
                if (error) {
                    reject(error);
                }
                resolve();
            });
        });
    };
    return {
        streams,
        actions: {
            async getSchemas() {
                return provider.getSchemas();
            },
            async getMetadata() {
                return provider.getMetadata();
            },
            async bootstrap() {
                return provider.bootstrap();
            },
            async close() {
                return provider.close();
            },
            async beforeTransfer() {
                return provider.beforeTransfer();
            },
            async rollback() {
                await provider.rollback();
            },
        },
        transfer: {
            async entities(entities) {
                if (!streams.entities) {
                    streams.entities = provider.createEntitiesWriteStream();
                }
                for (const entity of entities) {
                    if (streams.entities) {
                        await writeAsync(streams.entities, entity);
                    }
                }
            },
            async links(links) {
                if (!streams.links) {
                    streams.links = await provider.createLinksWriteStream();
                }
                for (const link of links) {
                    if (streams.links) {
                        await writeAsync(streams.links, link);
                    }
                }
            },
            async configuration(configs) {
                if (!streams.configuration) {
                    streams.configuration = await provider.createConfigurationWriteStream();
                }
                for (const config of configs) {
                    if (streams.configuration) {
                        await writeAsync(streams.configuration, config);
                    }
                }
            },
            async assets(payloads) {
                if (payloads === null) {
                    streams.assets?.end();
                    return;
                }
                if (!streams.assets) {
                    streams.assets = await provider.createAssetsWriteStream();
                }
                for (const payload of payloads) {
                    if (streams.assets.closed) {
                        return;
                    }
                    const { action, assetID } = payload;
                    if (action === 'start' && streams.assets) {
                        assets[assetID] = { ...payload.data, stream: new stream_chain_1.PassThrough() };
                        writeAsync(streams.assets, assets[assetID]);
                    }
                    if (action === 'stream') {
                        // The buffer has gone through JSON operations and is now of shape { type: "Buffer"; data: UInt8Array }
                        // We need to transform it back into a Buffer instance
                        const rawBuffer = payload.data;
                        const chunk = Buffer.from(rawBuffer.data);
                        await writeAsync(assets[assetID].stream, chunk);
                    }
                    if (action === 'end') {
                        await new Promise((resolve, reject) => {
                            const { stream } = assets[assetID];
                            stream
                                .on('close', () => {
                                delete assets[assetID];
                                resolve();
                            })
                                .on('error', (e) => {
                                reject(e);
                            })
                                .end();
                        });
                    }
                }
            },
        },
    };
};
exports.default = createPushController;
//# sourceMappingURL=push.js.map